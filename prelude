# let set f fexpr _if
# lang.is_list, envrionment.clone
# lang.tailcall, lang.expr, lang.exec

let ? let
let $ [f (x) { let e eval(x); _if lang.is_list(x) x.0 x  }]
let @ $

  # from inside if:
    # the latter would work better in a macro
    # @(lang.cond rest.0 => (_ => rest.0()), _ => ()),

let if [fexpr (cond, block, @rest) {
  # @rest is assumed to be either (elseblock) or ()
  let myenv [environment.clone env]
  let call [ _if
    [ lang.expr myenv cond ]
    block
    [ _if rest.0 rest.0 {} ]
  ]
  lang.exec myenv call
}]

let while [fexpr (cond, block) {
  let myenv [environment.clone env]
  if (lang.expr myenv cond) {
    lang.exec myenv block
    lang.tailcall cond block
  }
}]

let foreach [fexpr (name, args, block) {
  let idx -1
  let myenv [environment.clone env]
  let myargs lang.eval myenv args
  while (<= ++idx [list.last_index myargs]) {
    let thisenv [ environment.clone myenv ]
    set [ lang.eval thisenv x ] myargs(idx)
    lang.eval thisenv block
  }
}]
