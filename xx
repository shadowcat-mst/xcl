BEGIN {

package XCL::Parser;

use XCL::Class;

our $SYMBOL_CHARS = '!$%&*+-./:<=>@\^_|~';

sub extract_next ($self, $src) {
  state @types = (do {
    my @s = (
      [ ws => '\s' => '\s+' ],
      [ word => '[a-zA-Z]' => '\w+' ],
      [ number => '[0-9]', "[0-9]+(?:\\.[0-9]+)?" ],
      [ symbol => "[${SYMBOL_CHARS}]", "[${SYMBOL_CHARS}]+" ],
      [ comma => ',' ],
      [ semicolon => ';' ],
      [ startcall => "\\[" ],
      [ endcall => "\\]" ],
      [ startlist => "\\(" ],
      [ endlist => "\\)" ],
      [ startblock => "\\{" ],
      [ endblock => "\\}" ],
    );
    map { @$_ == 3 ? $_ : [ @{$_}[0,1], "(?:${$_}[1]+)" ] } @s;
  });

  foreach my $type (@types) {
    my ($name, $identify, $slurp) = @$type;
    if ($src =~ /^${identify}/sm) {
      $src =~ s/^(${slurp})//sm or die "WHAT";
      return ($name => $1, $src);
    }
  }
  die "ALSO WHAT";
}

sub _add_meta ($thing, $meta) {
  my $r = [ $thing->[0], { %$meta }, $thing->[1] ];
  %$meta = ();
  return $r;
}

sub parse_script ($self, $src) {
  my @parse;
  my %meta;
  my @atoms;
  TOK: while ($src !~ /^\Z/) {
    (my ($type, $tok), $src) = $self->extract_next($src);
    if ($type eq 'ws') {
      die "Two ws tokens in a row indicates a tokenizer bug"
        if defined $meta{ws_before};
      if (@atoms) {
        if (@atoms == 1) {
          push @parse, @atoms;
        } else {
          my $cmeta = $atoms[0][1];
          $atoms[0][1] = {};
          push @parse, [ compound => $cmeta => [ @atoms ] ];
        }
        @atoms = ();
      }
      $meta{ws_before} = $tok;
    } elsif ($type eq 'word') {
      push @atoms, _add_meta([ $type, $tok ], \%meta);
    } elsif ($type eq 'number') {
      push @atoms, _add_meta(
        ($tok =~ /\./ ? [ float => $tok ] : [ int => $tok ]),
        \%meta
      );
    } elsif ($type eq 'symbol') {
      push @atoms, _add_meta([ $type, $tok ], \%meta);
    }
  }
  return \@parse;
}

sub all_tokens ($self, $src) {
  my @tok;
  while ($src !~ /^\Z/) {
    (my $tok, $src) = $self->extract_next($src);
    push @tok, $tok;
  }
  return \@tok;
}

1;

}

use strictures 2;
use Devel::DDCWarn;

my $p = XCL::Parser->new;

::Dwarn $p->parse_script(qq{+ 3.0 foo4x! ]});

#::Dwarn $p->parse_script(qq{
#  foo \$bar [ baz ];
#  if (thing) \\{ do_stuff() \\}
#});
