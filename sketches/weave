#{{{

let make (type, data) { type.make data };

let push (list, v) { list[list.count] = v };

newvar foreach [fexpr (env, name, lproto, body) {
  newvar lst [evaluate env lproto];
  newvar end [[List 'count_of'] lst];
  newvar cur 0;
  newvar res ();
  while (< cur end) {
    newvar denv [ derive_env env %((name, lst(cur))) ];
    push res [ evaluate denv [ make Call (body) ] ];
    set cur [+ cur 1];
  }
  $res;
}];

let range (from, to) {
  let var cur = from;
  let var res = ();
  while (<= cur to) {
    push res cur;
    ++cur;
  }
  $res;
}];

}}}#

let weave_call (call) {
  let call_list = call.list();
  if [ exists let op_idx = call_list
                             . pairs()
                             . where_val(_OPS.has)
                             . min_by_val(_OPS)
                             . keys ] {
    Call.make (
      call_list(op_idx),
      weave_call(Call.make call_list(0 .. op_idx-1)),
      weave_call(Call.make call_list(op_idx+1 .. call_list.last_index()),
    );
  } {
    Call.make weave_list(call_list);
  }
}

let weaver_for %(
  :Int $,
  :Float $,
  :String $,
  :List list => list.map(weave),
  :Dict dict => dict.map_val(weave),
  :Call weave_call,
);

let weave (args) {
  weaver_for(type_of args) args;
};

__END__

newvar map [fexpr (env, call, lproto) {
  evaluate env [make Call [make List foreach _ lproto call]];
}];
  
newvar weave_dict [lambda (dict) {
  %(map { $ (_(0), weave _(1)) } [Dict 'pairs_of'](dict));
}];

newvar weave_list [lambda (lst) [
  map { weave _ } lst;
}];

newvar weave_call [lambda (call) {
  newvar op_idx 0;
  newvar op_prec 0;
  newvar lst [Call 'list'](call);
  foreach idx range(0, - count_of(lst) 1) {
    if idx {
      if [Dict 'has'](ops, lst(idx)) {
        newvar this_op lst(idx);
        newvar this_prec ops(this_op);
        if [< this_prec op_prec] {
          set op_idx idx;
          set op_prec this_prec;
        }
      }
    }
  }
  if op_idx {
    newvar ret ();
    newvar op lst(op_idx);
    newvar left [map { lst _ } [range 0 [- op_idx 1 ]]];
    newvar right [map { lst _ } range(+ op_idx 1, - count_of(lst) 1);
    make Call (op,
      weave_call(make Call left),
      weave_call(make Call right)
    );
  } {
    # no binop found
    make Call weave_list(lst);
  }
}];

newvar weaver_for %(
  :Int $,
  :Float $,
  :String $,
  :List weave_list,
  :Dict weave_dict,
  :Call weave_call,
);

newvar weave [fexpr (env, args) {
  weaver_for(type_of args) args;
}];
