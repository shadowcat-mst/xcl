package XCL::Values;

use strictures 2;
use curry;
use Exporter 'import';
use experimental 'signatures';

# string, bytes
# float, int
# name, bool
# list, dict
# call, block

package XCL::V {
  sub eval ($self, $env) { XCL::Values::Result({ val => $self }) }
  sub data ($self) { $self->{data} }
  sub metadata ($self) { $self->{metadata} }
  sub invoke ($self, @) { die "Not invokable: $self" }
}

BEGIN {

  our @Types = qw(
    String Bytes
    Float Int
    Bool
    Fexpr Dict List
    Name
    Call
    Result
    Bultin
  );

  our @EXPORT = @Types;

  foreach my $type (@Types) {
    my $class = "XCL::V::${type}";
    {
      no 'strict';
      @{"${class}::ISA"} = qw(XCL::V);
      *{$type} = sub ($data, $metadata = {}) {
        bless({ data => $data, metadata => $metadata }, $class);
      }
    }
  }
}

sub XCL::V::Escape::eval ($self, $env) { Result($self->data) }

sub XCL::V::Call::eval ($self, $env) {
  my ($command, @args) = @{$self->data};
  if ((my $res = $command->eval($env))->is_ok) {
    return $res->val->invoke($env, @args);
  } else {
    return $res;
  }
}

sub XCL::V::Name::eval ($self, $env) { $env->get($self->data) }

sub XCL::V::Fexpr::invoke ($self, @args) {
  my ($argspec, $env, $body) = @{$self->data}{qw(argspec env body)};
  my %merge; @merge{@$argspec} = @args;
  $body->eval($env->derive(\%merge));
}

package XCL::V::Dict {
  BEGIN { *Result = *XCL::Values::Result }
  sub get ($self, $key) {
    my $dict = $self->data;
    Result({
     ($dict->{$key}
       ? (val => $dict->{$key})
       : (err => 'NO_SUCH_VALUE')
      ),
      set => $self->curry::weak::set($key);
    });
  }
  sub set ($self, $key, $value) {
    $self->data->{$key} = $value;
    Result({ val => $value });
  }
  sub invoke ($self, $string) {
    return Result(err => 'NOT_A_STRING')
      unless $string->isa('DX::Value::String');
    $self->get($self, $string->data);
  }
}

package XCL::V::List {
  BEGIN { *Result = *XCL::Values::Result }
  sub get ($self, $idx) {
    die "NOT YET" if $idx < 0;
    my $ary = $self->data;
    Result({
     ($#$ary <= $idx
       ? (val => $ary->[$idx])
       : (err => 'NO_SUCH_VALUE')),
     (set => $self->curry::weak::set($idx)),
    });
  }
  sub set ($self, $idx, $value) {
    die "NOT YET" if $idx < 0;
    my $ary = $self->data;
    return Result({ err => 'NO_SUCH_INDEX' }) if $idx > @$ary;
    $ary->[$idx] = $value;
    Result({ val => $value });
  }
  sub invoke ($self, $int) {
    return Result(err => 'NOT_AN_INT') unless $int->isa('DX::Value::Int');
    $self->get($self, $int->data);
  }
}

package XCL::V::Result {
  sub is_ok ($self) { exists $self->data->{val} }
  sub val ($self) { $self->data->{val} }
  sub err ($self) { $self->data->{err} }
  sub can_set ($self) { exists $self->data->{set} }
  sub set ($self, $value) {
    $self->data->{$set}->($value);
  }
}

sub XCL::V::Builtin::invoke ($self, @args) { $self->data->(@args) }

package XCL::Builtins {
  BEGIN { *Result = *XCL::Values::Result }
  BEGIN { *List = *XCL::Values::List }
  sub _eval ($env, @args) {
    my @ret;
    foreach my $arg (@args) {
      my $r = $env->eval($arg);
      return $r unless $r->is_ok;
      push @rest, $r->val;
    }
    return Result({ val => List(\@ret)( });
  }
  my $MAX_SAFE_INT = 2**53;
  sub plus {
    my $res = _eval(@_);
    return $res->err unless $res->is_ok;
    my ($first, @rest) = @{$res->val->data};
    my $type = ref($first);
    die "Incorrect types" if grep ref($_) ne $type, @rest;
    my $acc = $first->data;
    foreach my $val (map $_->data, @rest) {
      if ($type =~ /Int$/ and $MAX_SAFE_INT - $acc > $val) {
        die "Possible integer overflow";
      }
      $acc += $val;
    }
    bless({ data => $acc }, $type);
  }
  sub progn {
    my ($env, @args) = @_;
    my $r;
    foreach my $arg (@args) {
      $r = $arg->eval($env);
      return $r unless $r->is_ok;
    }
    return $r;
  }
}

1;
